'''
Created on Jun 6, 2014

@author: jeromethai
'''

import numpy as np
import ue_solver as ue
import inverse_opt as invopt
from test_graph import los_angeles
import matplotlib.pyplot as plt
from cvxopt import matrix
from numpy.random import normal

od_flows1 = [3.0, 3.0, 1.0, 1.0];
od_flows2 = [1.0, 1.0, 1.0, 4.0];
theta_true = matrix([0.0, 0.0, 0.0, 0.15, 0.0, 0.0])
degree = len(theta_true)
graph = los_angeles(theta_true, 'Polynomial')[0]

    
def display_results(true_linkflows, est_linkflows, theta_true, best_theta):
    """Display results
    
    Parameters
    ----------
    true_linkflows: list of true linkflows
    est_linkflows: list of estimated linkflows
    theta_true: true parameters
    best_theta: best parameters
    """
    error = np.linalg.norm(matrix(true_linkflows) - matrix(est_linkflows))
    xdata = np.linspace(0.0, 2.5, num=100)
    vals = [1+(best_theta.T * matrix(np.power(x,range(1,degree+1))))[0] for x in xdata]
    true_vals = [1+(theta_true.T * matrix(np.power(x,range(1,degree+1))))[0] for x in xdata]
    plt.plot(xdata, vals, 'r', label='estimate')
    plt.plot( xdata, true_vals, 'b', label='true')
    plt.xlabel('Link flow')
    plt.ylabel('Delay')
    plt.title(r'Estimated delay function. l2-norm error: {:.3f}'.format(error))
    plt.legend()
    plt.show()
    
    
def get_graphs_linkflows(theta, noisy=False):
    """Given parameters theta, get L.A. graphs and associated UE linkflows for polynomial delay functions
    """
    g1, g2, g3, g4 = los_angeles(theta, 'Polynomial', noisy)
    l1, l2, l3, l4 = ue.solver(g1), ue.solver(g2), ue.solver(g3), ue.solver(g4)
    return g1, g2, g3, g4, l1, l2, l3, l4
    
    
def test1():
    """find smooth parameter that minimizes ||x_true-x|| without noise and with all observations
    best parameter = [0.1]*6
    """
    g1, g2, g3, g4, l1, l2, l3, l4 = get_graphs_linkflows(theta_true)
    min_error = np.inf
    for i in [0.01, 0.1, 1.0]:
        theta = invopt.solver([g1, g2, g3, g4], [l1, l2, l3, l4], degree, i*np.ones(degree))
        g1, g2, g3, g4, x1, x2, x3, x4 = get_graphs_linkflows(theta)
        error = np.linalg.norm(matrix([l1,l2,l3,l4])-matrix([x1,x2,x3,x4]))
        if error < min_error:
            best_smooth, min_error, best_theta, y1, y2, y3, y4 = i, error, theta, x1, x2, x3, x4
    print best_smooth, min_error
    print best_theta
    display_results([l1, l2, l3, l4], [y1, y2, y3, y4], theta_true, best_theta)
    

def test2():
    """find smooth parameter using cross validation without noise and with all observations
    average over four results = [2.5]*6
    """
    g1, g2, g3, g4, l1, l2, l3, l4 = get_graphs_linkflows(theta_true)
    gs, ls = [g1,g2,g3,g4], [l1,l2,l3,l4]
    best_smooth = [0.0]*4
    
    for index in range(4):
        min_error = np.inf
        for i in [0.00001, 0.0001, 0.001, 0.01, 0.1, 1.0, 10.0, 100.0]:
            theta = invopt.solver(gs[:index]+gs[index+1:], ls[:index]+ls[index+1:], degree, i*np.ones(degree))
            l = get_graphs_linkflows(theta)[4+index]
            error = np.linalg.norm(ls[index]-l)
            if error < min_error: best_smooth[index], min_error = i, error    
    print best_smooth


def test3(indlinks_obs):
    """Test x_solver, compute_lower, and compute_coefs
    """
    g1, g2, g3, g4, l1, l2, l3, l4 = get_graphs_linkflows(theta_true)
    obs = [g4.indlinks[id] for id in indlinks_obs]
    ffdelays, slopes, coefs = g4.get_ffdelays(), g4.get_slopes(), g4.get_coefs()
    Aeq, beq = ue.constraints(g4)
    C = ue.get_nodelink_incidence(g4)[0]
    lower = invopt.compute_lower(C, matrix(10.0, (Aeq.size[0],1)), ffdelays, slopes, coefs)
    print invopt.x_solver(ffdelays, coefs, Aeq, beq, 1000.0, obs, l4[obs], lower)
    print invopt.compute_coefs(ffdelays, slopes, theta_true)

    
def test4(indlinks_obs):
    """find smooth that minimizes the distance between x^obs_true EXACT
    and x^obs generated by each candidate function with PARTIAL observation
    """
    g1, g2, g3, g4, l1, l2, l3, l4 = get_graphs_linkflows(theta_true)
    obs = [g1.indlinks[id] for id in indlinks_obs]
    min_error = np.inf
    for i in [10.0]:
        for j in [0.0001, 0.001, 0.01, 0.1, 1.0]:
            theta = invopt.solver_mis([g1, g2, g3, g4], [l1[obs], l2[obs], l3[obs], l4[obs]], 
                              indlinks_obs, degree, i*np.ones(degree), j)
            g1, g2, g3, g4, x1, x2, x3, x4 = get_graphs_linkflows(theta)
            e = np.linalg.norm(matrix([l1[obs],l2[obs],l3[obs],l4[obs]])-matrix([x1[obs],x2[obs],x3[obs],x4[obs]]))
            if e < min_error:
                best_param, min_error, best_theta = (i,j), e, theta
                y1, y2, y3, y4 = x1, x2, x3, x4        
    print min_error, best_param
    print best_theta
    display_results([l1, l2, l3, l4], [y1, y2, y3, y4], theta_true, best_theta)
    
    
def test5(indlinks_obs):
    """3-fold test to find smooth that minimizes the distance between x^obs_true
    and x^obs generated by each candidate function in NOISY case with PARTIAL observation
    results for 3-fold with alt=False, obs = [(17,24),(24,40),(14,21),(16,23)]: best smooth = [30, 30, 600, 600, 600, 600]
    results for 3-fold with alt=True, obs = [(17,24),(24,40),(14,21),(16,23)]: best smooth = [100, 100, 100, 100, 1000, 1000]
    """
    g1, g2, g3, g4, l1, l2, l3, l4 = get_graphs_linkflows(theta_true)
    obs = [g1.indlinks[id] for id in indlinks_obs]
    z1, z2, z3, z4 = l1, l2, l3, l4
    np.random.seed(21)
    l1, l2, l3, l4 = matrix(normal(l1, l1/30.0)), matrix(normal(l2, l2/30.0)), matrix(normal(l3, l3/30.0)), matrix(normal(l4, l4/30.0))
    g1, g2, g3, g4 = los_angeles(theta_true, 'Polynomial', True)
    min_error = np.inf
    for i in [100.0]:
        for j in [100.0]:
            for k in [1000.0]:
                smooth = np.hstack((i*np.ones(degree/3), j*np.ones(degree/3), k*np.ones(degree/3)))
                theta = invopt.solver_mis([g1, g2, g3, g4], [l1[obs], l2[obs], l3[obs], l4[obs]], 
                                  indlinks_obs, degree, smooth)
                g1, g2, g3, g4, x1, x2, x3, x4 = get_graphs_linkflows(theta, True)
                e = np.linalg.norm(matrix([l1[obs],l2[obs],l3[obs],l4[obs]])-matrix([x1[obs],x2[obs],x3[obs],x4[obs]]))
                if e < min_error:
                    best_smooth, min_error, best_theta = (i,j,k), e, theta
                    y1, y2, y3, y4 = x1, x2, x3, x4         
    print best_smooth, min_error
    l1, l2, l3, l4 = z1, z2, z3, z4
    display_results([l1, l2, l3, l4], [y1, y2, y3, y4], theta_true, best_theta)
    
    
def test6(noisy=False):
    """Cross validation to find a sensor that has been attacked
    results when obs = [(17,24),(24,40),(14,21),(16,23)] and (24,40) has been attacked
    """
    indlinks_obs = [(17,24,1), (24,40,1), (14,21,1), (16,23,1)]
    g1, g2, g3, g4, l1, l2, l3, l4 = get_graphs_linkflows(theta_true)
    if noisy:
        g1, g2, g3, g4 = los_angeles(theta_true, 'Polynomial', True)
        l1, l2, l3, l4 = matrix(normal(l1, l1/30.0)), matrix(normal(l2, l2/30.0)), matrix(normal(l3, l3/30.0)), matrix(normal(l4, l4/30.0))
    faulty_id = g1.indlinks[(24,40,1)]
    l1[faulty_id], l2[faulty_id], l3[faulty_id], l4[faulty_id] = 0.7*l1[faulty_id], 0.7*l2[faulty_id], 0.7*l3[faulty_id], 0.7*l4[faulty_id]
    min_error = []
    for k in range(4):
        indlinks = list(indlinks_obs)
        del indlinks[k]
        obs = [g1.indlinks[id] for id in indlinks]
        min_e = np.inf
        for i in [30.0, 60.0, 100.0]:
            for j in [30.0, 60.0, 100.0]:
                for k in [3000.0, 6000.0, 10000.0]:
                    smooth = np.hstack((i*np.ones(degree/3), j*np.ones(degree/3), k*np.ones(degree/3)))
                    theta = invopt.solver_mis([g1, g2, g3, g4], [l1[obs], l2[obs], l3[obs], l4[obs]], 
                                  indlinks, degree, smooth)
                    g1, g2, g3, g4, x1, x2, x3, x4 = get_graphs_linkflows(theta, noisy)
                    e = np.linalg.norm(matrix([l1[obs],l2[obs],l3[obs],l4[obs]])-matrix([x1[obs],x2[obs],x3[obs],x4[obs]]))
                    if e < min_e: min_e = e
        min_error.append(min_e)
    print min_error
    

def main():
    
    #indlinks_obs = [(17,24,1), (24,40,1), (14,21,1), (16,23,1)]
    indlinks_obs = graph.indlinks.keys()
    #indlinks_obs = []
    #indlinks_obs = [(10,9,1), (19,18,1), (4,5,1), (29,21,1)]
    
    #test1()
    #test2()
    #test3(indlinks_obs)
    test4(indlinks_obs)
    #test5(indlinks_obs)
    #test6(True)
    
if __name__ == '__main__':
    main()